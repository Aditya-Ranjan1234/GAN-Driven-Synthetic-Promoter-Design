"""
Streamlit app for comparing original DNA sequences with synthetic sequences generated by different GAN models.

This app allows users to:
1. View original DNA sequences
2. View synthetic DNA sequences generated by different models
3. Compare evaluation metrics between models
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import sys
import torch
from Bio import SeqIO
from io import StringIO
import re
import json
from collections import Counter

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Set page config
st.set_page_config(
    page_title="DNA Sequence Comparison Dashboard",
    page_icon="ðŸ§¬",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Define functions for data loading and visualization

def load_fasta_sequences(file_path, max_sequences=100):
    """Load sequences from a FASTA file."""
    sequences = []
    for record in SeqIO.parse(file_path, "fasta"):
        seq = str(record.seq).upper()

        # Remove 'N' characters first
        seq = seq.replace('N', '')

        # Remove any other non-standard nucleotides
        seq = re.sub(r'[^ACGT]', '', seq)

        if seq:
            # Truncate very long sequences to 150 nucleotides
            if len(seq) > 150:
                seq = seq[:150]

            sequences.append({
                'id': record.id,
                'sequence': seq,
                'length': len(seq)
            })

        if len(sequences) >= max_sequences:
            break
    return sequences

def calculate_nucleotide_frequencies(sequences):
    """Calculate nucleotide frequencies in sequences."""
    nucleotide_counts = Counter()
    total_nucleotides = 0

    for seq_data in sequences:
        seq = seq_data['sequence']
        nucleotide_counts.update(seq)
        total_nucleotides += len(seq)

    frequencies = {
        'A': nucleotide_counts.get('A', 0) / total_nucleotides,
        'C': nucleotide_counts.get('C', 0) / total_nucleotides,
        'G': nucleotide_counts.get('G', 0) / total_nucleotides,
        'T': nucleotide_counts.get('T', 0) / total_nucleotides
    }

    return frequencies

def calculate_gc_content_from_sequences(sequences):
    """Calculate GC content from sequences."""
    gc_count = 0
    total_count = 0

    for seq_data in sequences:
        seq = seq_data['sequence']
        gc_count += seq.count('G') + seq.count('C')
        total_count += len(seq)

    return gc_count / total_count if total_count > 0 else 0

def calculate_kmer_frequencies(sequences, k=3):
    """Calculate k-mer frequencies in sequences."""
    kmer_counts = Counter()
    total_kmers = 0

    for seq_data in sequences:
        seq = seq_data['sequence']
        if len(seq) >= k:
            for i in range(len(seq) - k + 1):
                kmer = seq[i:i+k]
                kmer_counts[kmer] += 1
                total_kmers += 1

    # Get top 20 k-mers
    top_kmers = kmer_counts.most_common(20)

    frequencies = {}
    for kmer, count in top_kmers:
        frequencies[kmer] = count / total_kmers

    return frequencies

def plot_nucleotide_distribution(frequencies, title="Nucleotide Distribution"):
    """Plot nucleotide distribution."""
    fig, ax = plt.subplots(figsize=(8, 5))

    nucleotides = list(frequencies.keys())
    counts = list(frequencies.values())

    ax.bar(nucleotides, counts, color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'])
    ax.set_ylabel('Frequency')
    ax.set_title(title)
    ax.grid(axis='y', linestyle='--', alpha=0.7)

    # Add percentage labels
    for i, v in enumerate(counts):
        ax.text(i, v + 0.01, f"{v:.2%}", ha='center')

    return fig

def plot_kmer_distribution(frequencies, title="Top 20 k-mer Distribution"):
    """Plot k-mer distribution."""
    fig, ax = plt.subplots(figsize=(12, 6))

    kmers = list(frequencies.keys())
    counts = list(frequencies.values())

    # Sort by frequency
    sorted_indices = np.argsort(counts)[::-1]
    kmers = [kmers[i] for i in sorted_indices]
    counts = [counts[i] for i in sorted_indices]

    ax.bar(kmers, counts)
    ax.set_ylabel('Frequency')
    ax.set_title(title)
    ax.set_xticklabels(kmers, rotation=45, ha='right')
    ax.grid(axis='y', linestyle='--', alpha=0.7)

    plt.tight_layout()
    return fig

def plot_sequence_length_distribution(sequences, title="Sequence Length Distribution"):
    """Plot sequence length distribution."""
    lengths = [seq_data['length'] for seq_data in sequences]

    fig, ax = plt.subplots(figsize=(10, 6))

    sns.histplot(lengths, bins=30, kde=True, ax=ax)
    ax.set_xlabel('Sequence Length')
    ax.set_ylabel('Count')
    ax.set_title(title)
    ax.grid(linestyle='--', alpha=0.7)

    return fig

def compare_metrics(original_sequences, gumbel_sequences, improved_sequences):
    """Compare metrics between original and generated sequences."""
    metrics = {
        'GC Content': [
            calculate_gc_content_from_sequences(original_sequences),
            calculate_gc_content_from_sequences(gumbel_sequences),
            calculate_gc_content_from_sequences(improved_sequences)
        ],
        'Sequence Diversity': [
            len(set([seq['sequence'] for seq in original_sequences])) / len(original_sequences),
            len(set([seq['sequence'] for seq in gumbel_sequences])) / len(gumbel_sequences),
            len(set([seq['sequence'] for seq in improved_sequences])) / len(improved_sequences)
        ],
        'Average Length': [
            np.mean([seq['length'] for seq in original_sequences]),
            np.mean([seq['length'] for seq in gumbel_sequences]),
            np.mean([seq['length'] for seq in improved_sequences])
        ]
    }

    # Create DataFrame
    df = pd.DataFrame(metrics, index=['Original', 'Gumbel-Softmax GAN', 'Improved WGAN-GP'])

    return df

def plot_metrics_comparison(metrics_df):
    """Plot metrics comparison."""
    fig, axs = plt.subplots(1, len(metrics_df.columns), figsize=(15, 5))

    for i, metric in enumerate(metrics_df.columns):
        axs[i].bar(metrics_df.index, metrics_df[metric])
        axs[i].set_title(metric)
        axs[i].set_ylabel('Value')
        axs[i].tick_params(axis='x', rotation=45)
        axs[i].grid(axis='y', linestyle='--', alpha=0.7)

    plt.tight_layout()
    return fig

def generate_sequences(model_type, num_sequences=100):
    """
    Generate DNA sequences using the specified model.

    Args:
        model_type (str): Type of model ('gumbel' or 'improved')
        num_sequences (int): Number of sequences to generate

    Returns:
        list: List of generated sequences
    """
    if model_type == 'gumbel':
        # Path to the Gumbel-Softmax GAN checkpoint
        checkpoint_path = "../models/gumbel_softmax_gan/checkpoints/final_model.pt"
        output_path = "../data/gumbel_generated_sequences.fasta"

        # Run the generation script
        os.system(f"python ../models/gumbel_softmax_gan/generate_sequences.py --checkpoint {checkpoint_path} --num_sequences {num_sequences} --output_file {output_path}")

    else:  # improved
        # Path to the Improved WGAN-GP checkpoint
        checkpoint_path = "../models/improved_wgan/checkpoints/improved_dna_gan/final_model.pt"
        output_path = "../data/improved_generated_sequences.fasta"

        # Run the generation script
        os.system(f"python ../models/improved_wgan/generate_sequences.py --checkpoint {checkpoint_path} --num_sequences {num_sequences} --output_file {output_path}")

    # Load and return the generated sequences
    if os.path.exists(output_path):
        return load_fasta_sequences(output_path, max_sequences=num_sequences)
    else:
        st.error(f"Failed to generate sequences. Output file not found: {output_path}")
        return []

# Main app
def main():
    st.title("ðŸ§¬ DNA Sequence Comparison Dashboard")

    # Sidebar
    st.sidebar.title("Navigation")
    page = st.sidebar.radio(
        "Select a page",
        ["Home", "Original Data", "Generated Data", "Model Comparison", "Evaluation"]
    )

    # Data paths
    data_path = "../data"
    original_data_path = os.path.join(data_path, "clean_seq_download.fasta")

    # If the cleaned file doesn't exist, try to extract it
    if not os.path.exists(original_data_path) and os.path.exists(os.path.join(data_path, "seq_download.pl.fasta")):
        try:
            # Import the extraction function
            sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
            from utils.extract_fasta_from_html import extract_fasta_from_html

            # Extract FASTA content
            extract_fasta_from_html(
                os.path.join(data_path, "seq_download.pl.fasta"),
                original_data_path
            )

            st.sidebar.success("Successfully extracted FASTA content from HTML file.")
        except Exception as e:
            st.sidebar.error(f"Error extracting FASTA content: {e}")
            # Fall back to the original file
            original_data_path = os.path.join(data_path, "seq_download.pl.fasta")

    gumbel_data_path = os.path.join(data_path, "gumbel_generated_sequences.fasta")
    improved_data_path = os.path.join(data_path, "improved_generated_sequences.fasta")

    # Check if files exist, otherwise use placeholders
    if not os.path.exists(original_data_path):
        st.sidebar.warning(f"Original data file not found: {original_data_path}")
        original_data_path = None

    if not os.path.exists(gumbel_data_path):
        st.sidebar.warning(f"Gumbel-Softmax generated data file not found: {gumbel_data_path}")
        gumbel_data_path = None

    if not os.path.exists(improved_data_path):
        st.sidebar.warning(f"Improved WGAN-GP generated data file not found: {improved_data_path}")
        improved_data_path = None

    # Home page
    if page == "Home":
        st.header("Welcome to the DNA Sequence Comparison Dashboard")

        st.markdown("""
        This dashboard allows you to compare DNA sequences generated by different GAN models with the original data.

        ### Available Models:

        1. **Gumbel-Softmax GAN**
           - Uses LSTM generator with 256 hidden units
           - Applies Gumbel-Softmax trick for backpropagation through discrete outputs

        2. **Improved WGAN-GP**
           - Uses Wasserstein loss with gradient penalty
           - LSTM generator with self-attention mechanism
           - More stable training and better diversity

        ### Features:

        - View original DNA sequences
        - Generate and explore synthetic sequences from both models
        - Compare evaluation metrics between original and generated sequences

        Use the navigation panel on the left to explore different sections.
        """)

        # Generate sequences button
        st.subheader("Generate Sequences")

        col1, col2 = st.columns(2)

        with col1:
            if st.button("Generate Sequences with Gumbel-Softmax GAN"):
                with st.spinner("Generating sequences with Gumbel-Softmax GAN..."):
                    generate_sequences('gumbel', num_sequences=100)
                st.success("Sequences generated successfully!")

        with col2:
            if st.button("Generate Sequences with Improved WGAN-GP"):
                with st.spinner("Generating sequences with Improved WGAN-GP..."):
                    generate_sequences('improved', num_sequences=100)
                st.success("Sequences generated successfully!")

    # Original Data page
    elif page == "Original Data":
        st.header("Original DNA Sequences")

        if original_data_path and os.path.exists(original_data_path):
            original_sequences = load_fasta_sequences(original_data_path)

            st.subheader("Sample Sequences")
            sample_df = pd.DataFrame([
                {'ID': seq['id'], 'Sequence': seq['sequence'], 'Length': seq['length']}
                for seq in original_sequences[:10]
            ])
            st.dataframe(sample_df)

            col1, col2 = st.columns(2)

            with col1:
                st.subheader("Nucleotide Distribution")
                nucleotide_freq = calculate_nucleotide_frequencies(original_sequences)
                fig = plot_nucleotide_distribution(nucleotide_freq, "Original Data Nucleotide Distribution")
                st.pyplot(fig)

                st.subheader("GC Content")
                gc_content = calculate_gc_content_from_sequences(original_sequences)
                st.metric("GC Content", f"{gc_content:.2%}")

            with col2:
                st.subheader("Sequence Length Distribution")
                fig = plot_sequence_length_distribution(original_sequences)
                st.pyplot(fig)

                st.subheader("Top k-mers (k=3)")
                kmer_freq = calculate_kmer_frequencies(original_sequences, k=3)
                fig = plot_kmer_distribution(kmer_freq)
                st.pyplot(fig)
        else:
            st.error("Original data file not found. Please check the file path.")

    # Generated Data page
    elif page == "Generated Data":
        st.header("Generated DNA Sequences")

        model_option = st.selectbox(
            "Select model",
            ["Gumbel-Softmax GAN", "Improved WGAN-GP"]
        )

        # Add a button to generate new sequences
        if st.button(f"Generate New Sequences with {model_option}"):
            with st.spinner(f"Generating sequences with {model_option}..."):
                if model_option == "Gumbel-Softmax GAN":
                    generate_sequences('gumbel', num_sequences=100)
                else:
                    generate_sequences('improved', num_sequences=100)
            st.success("Sequences generated successfully!")

        if model_option == "Gumbel-Softmax GAN":
            if gumbel_data_path and os.path.exists(gumbel_data_path):
                gumbel_sequences = load_fasta_sequences(gumbel_data_path)

                st.subheader("Sample Generated Sequences")
                sample_df = pd.DataFrame([
                    {'ID': seq['id'], 'Sequence': seq['sequence'], 'Length': seq['length']}
                    for seq in gumbel_sequences[:10]
                ])
                st.dataframe(sample_df)

                col1, col2 = st.columns(2)

                with col1:
                    st.subheader("Nucleotide Distribution")
                    nucleotide_freq = calculate_nucleotide_frequencies(gumbel_sequences)
                    fig = plot_nucleotide_distribution(nucleotide_freq, "Gumbel-Softmax GAN Nucleotide Distribution")
                    st.pyplot(fig)

                    st.subheader("GC Content")
                    gc_content = calculate_gc_content_from_sequences(gumbel_sequences)
                    st.metric("GC Content", f"{gc_content:.2%}")

                with col2:
                    st.subheader("Sequence Length Distribution")
                    fig = plot_sequence_length_distribution(gumbel_sequences)
                    st.pyplot(fig)

                    st.subheader("Top k-mers (k=3)")
                    kmer_freq = calculate_kmer_frequencies(gumbel_sequences, k=3)
                    fig = plot_kmer_distribution(kmer_freq)
                    st.pyplot(fig)
            else:
                st.error("Gumbel-Softmax generated data file not found. Please generate sequences first.")

        else:  # Improved WGAN-GP
            if improved_data_path and os.path.exists(improved_data_path):
                improved_sequences = load_fasta_sequences(improved_data_path)

                st.subheader("Sample Generated Sequences")
                sample_df = pd.DataFrame([
                    {'ID': seq['id'], 'Sequence': seq['sequence'], 'Length': seq['length']}
                    for seq in improved_sequences[:10]
                ])
                st.dataframe(sample_df)

                col1, col2 = st.columns(2)

                with col1:
                    st.subheader("Nucleotide Distribution")
                    nucleotide_freq = calculate_nucleotide_frequencies(improved_sequences)
                    fig = plot_nucleotide_distribution(nucleotide_freq, "Improved WGAN-GP Nucleotide Distribution")
                    st.pyplot(fig)

                    st.subheader("GC Content")
                    gc_content = calculate_gc_content_from_sequences(improved_sequences)
                    st.metric("GC Content", f"{gc_content:.2%}")

                with col2:
                    st.subheader("Sequence Length Distribution")
                    fig = plot_sequence_length_distribution(improved_sequences)
                    st.pyplot(fig)

                    st.subheader("Top k-mers (k=3)")
                    kmer_freq = calculate_kmer_frequencies(improved_sequences, k=3)
                    fig = plot_kmer_distribution(kmer_freq)
                    st.pyplot(fig)
            else:
                st.error("Improved WGAN-GP generated data file not found. Please generate sequences first.")

    # Model Comparison page
    elif page == "Model Comparison":
        st.header("Model Comparison")

        # Add a button to generate new sequences for both models
        if st.button("Generate New Sequences for Both Models"):
            with st.spinner("Generating sequences..."):
                generate_sequences('gumbel', num_sequences=100)
                generate_sequences('improved', num_sequences=100)
            st.success("Sequences generated successfully!")

        # Load data if available
        original_sequences = []
        gumbel_sequences = []
        improved_sequences = []

        if original_data_path and os.path.exists(original_data_path):
            original_sequences = load_fasta_sequences(original_data_path)
        else:
            st.error("Original data file not found. Please check the file path.")

        if gumbel_data_path and os.path.exists(gumbel_data_path):
            gumbel_sequences = load_fasta_sequences(gumbel_data_path)
        else:
            st.error("Gumbel-Softmax generated data file not found. Please generate sequences first.")

        if improved_data_path and os.path.exists(improved_data_path):
            improved_sequences = load_fasta_sequences(improved_data_path)
        else:
            st.error("Improved WGAN-GP generated data file not found. Please generate sequences first.")

        if original_sequences and gumbel_sequences and improved_sequences:
            # Compare metrics
            metrics_df = compare_metrics(original_sequences, gumbel_sequences, improved_sequences)

            st.subheader("Metrics Comparison")
            st.dataframe(metrics_df.style.format("{:.4f}"))

    # Evaluation page
    elif page == "Evaluation":
        # Import the evaluation page module
        from visualization.streamlit_evaluation_page import run_evaluation_page

        # Run the evaluation page
        run_evaluation_page()


if __name__ == "__main__":
    main()
