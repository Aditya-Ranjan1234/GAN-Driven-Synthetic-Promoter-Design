"""
Streamlit app for visualizing DNA sequence generation results.

This app allows users to:
1. View original DNA sequences
2. View synthetic DNA sequences generated by different models
3. Compare evaluation metrics between models
4. Visualize training progress
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import sys
import torch
from Bio import SeqIO
from io import StringIO
import re
import json
from collections import Counter

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import model modules
from models.improved_wgan.models import ImprovedGenerator, ImprovedDiscriminator
from models.improved_wgan.metrics import calculate_gc_content, calculate_morans_i, calculate_diversity, calculate_kmer_diversity

# Set page config
st.set_page_config(
    page_title="DNA Sequence Generation Dashboard",
    page_icon="ðŸ§¬",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Define functions for data loading and visualization

def load_fasta_sequences(file_path, max_sequences=100):
    """Load sequences from a FASTA file."""
    sequences = []
    for record in SeqIO.parse(file_path, "fasta"):
        seq = str(record.seq).upper()
        # Remove non-standard nucleotides
        seq = re.sub(r'[^ACGT]', '', seq)
        if seq:
            sequences.append({
                'id': record.id,
                'sequence': seq,
                'length': len(seq)
            })
        if len(sequences) >= max_sequences:
            break
    return sequences

def calculate_nucleotide_frequencies(sequences):
    """Calculate nucleotide frequencies in sequences."""
    nucleotide_counts = Counter()
    total_nucleotides = 0
    
    for seq_data in sequences:
        seq = seq_data['sequence']
        nucleotide_counts.update(seq)
        total_nucleotides += len(seq)
    
    frequencies = {
        'A': nucleotide_counts.get('A', 0) / total_nucleotides,
        'C': nucleotide_counts.get('C', 0) / total_nucleotides,
        'G': nucleotide_counts.get('G', 0) / total_nucleotides,
        'T': nucleotide_counts.get('T', 0) / total_nucleotides
    }
    
    return frequencies

def calculate_gc_content_from_sequences(sequences):
    """Calculate GC content from sequences."""
    gc_count = 0
    total_count = 0
    
    for seq_data in sequences:
        seq = seq_data['sequence']
        gc_count += seq.count('G') + seq.count('C')
        total_count += len(seq)
    
    return gc_count / total_count if total_count > 0 else 0

def calculate_kmer_frequencies(sequences, k=3):
    """Calculate k-mer frequencies in sequences."""
    kmer_counts = Counter()
    total_kmers = 0
    
    for seq_data in sequences:
        seq = seq_data['sequence']
        if len(seq) >= k:
            for i in range(len(seq) - k + 1):
                kmer = seq[i:i+k]
                kmer_counts[kmer] += 1
                total_kmers += 1
    
    # Get top 20 k-mers
    top_kmers = kmer_counts.most_common(20)
    
    frequencies = {}
    for kmer, count in top_kmers:
        frequencies[kmer] = count / total_kmers
    
    return frequencies

def plot_nucleotide_distribution(frequencies, title="Nucleotide Distribution"):
    """Plot nucleotide distribution."""
    fig, ax = plt.subplots(figsize=(8, 5))
    
    nucleotides = list(frequencies.keys())
    counts = list(frequencies.values())
    
    ax.bar(nucleotides, counts, color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'])
    ax.set_ylabel('Frequency')
    ax.set_title(title)
    ax.grid(axis='y', linestyle='--', alpha=0.7)
    
    # Add percentage labels
    for i, v in enumerate(counts):
        ax.text(i, v + 0.01, f"{v:.2%}", ha='center')
    
    return fig

def plot_kmer_distribution(frequencies, title="Top 20 k-mer Distribution"):
    """Plot k-mer distribution."""
    fig, ax = plt.subplots(figsize=(12, 6))
    
    kmers = list(frequencies.keys())
    counts = list(frequencies.values())
    
    # Sort by frequency
    sorted_indices = np.argsort(counts)[::-1]
    kmers = [kmers[i] for i in sorted_indices]
    counts = [counts[i] for i in sorted_indices]
    
    ax.bar(kmers, counts)
    ax.set_ylabel('Frequency')
    ax.set_title(title)
    ax.set_xticklabels(kmers, rotation=45, ha='right')
    ax.grid(axis='y', linestyle='--', alpha=0.7)
    
    plt.tight_layout()
    return fig

def plot_sequence_length_distribution(sequences, title="Sequence Length Distribution"):
    """Plot sequence length distribution."""
    lengths = [seq_data['length'] for seq_data in sequences]
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    sns.histplot(lengths, bins=30, kde=True, ax=ax)
    ax.set_xlabel('Sequence Length')
    ax.set_ylabel('Count')
    ax.set_title(title)
    ax.grid(linestyle='--', alpha=0.7)
    
    return fig

def plot_training_history(history_path, title="Training History"):
    """Plot training history."""
    try:
        with open(history_path, 'r') as f:
            history = json.load(f)
        
        fig, axs = plt.subplots(3, 2, figsize=(15, 15))
        
        # Plot losses
        axs[0, 0].plot(history.get('generator_loss', []), label='Generator Loss')
        axs[0, 0].plot(history.get('discriminator_loss', []), label='Discriminator Loss')
        axs[0, 0].set_xlabel('Epoch')
        axs[0, 0].set_ylabel('Loss')
        axs[0, 0].set_title('Generator and Discriminator Loss')
        axs[0, 0].legend()
        axs[0, 0].grid(True)
        
        # Plot Wasserstein distance
        if 'wasserstein_distance' in history:
            axs[0, 1].plot(history['wasserstein_distance'], label='Wasserstein Distance')
            axs[0, 1].set_xlabel('Epoch')
            axs[0, 1].set_ylabel('Distance')
            axs[0, 1].set_title('Wasserstein Distance')
            axs[0, 1].legend()
            axs[0, 1].grid(True)
        else:
            axs[0, 1].plot(history.get('discriminator_accuracy', []), label='Discriminator Accuracy')
            axs[0, 1].set_xlabel('Epoch')
            axs[0, 1].set_ylabel('Accuracy')
            axs[0, 1].set_title('Discriminator Accuracy')
            axs[0, 1].legend()
            axs[0, 1].grid(True)
        
        # Plot gradient penalty or other metric
        if 'gradient_penalty' in history:
            axs[1, 0].plot(history['gradient_penalty'], label='Gradient Penalty')
            axs[1, 0].set_xlabel('Epoch')
            axs[1, 0].set_ylabel('Penalty')
            axs[1, 0].set_title('Gradient Penalty')
            axs[1, 0].legend()
            axs[1, 0].grid(True)
        else:
            axs[1, 0].text(0.5, 0.5, 'No gradient penalty data available', 
                         horizontalalignment='center', verticalalignment='center',
                         transform=axs[1, 0].transAxes)
        
        # Plot GC content
        axs[1, 1].plot(history.get('gc_content', []), label='GC Content')
        axs[1, 1].set_xlabel('Epoch')
        axs[1, 1].set_ylabel('GC Content')
        axs[1, 1].set_title('GC Content')
        axs[1, 1].legend()
        axs[1, 1].grid(True)
        
        # Plot Moran's I
        axs[2, 0].plot(history.get('morans_i', []), label="Moran's I")
        axs[2, 0].set_xlabel('Epoch')
        axs[2, 0].set_ylabel('Value')
        axs[2, 0].set_title("Moran's I")
        axs[2, 0].legend()
        axs[2, 0].grid(True)
        
        # Plot diversity
        axs[2, 1].plot(history.get('diversity', []), label='Diversity')
        axs[2, 1].set_xlabel('Epoch')
        axs[2, 1].set_ylabel('Value')
        axs[2, 1].set_title('Diversity')
        axs[2, 1].legend()
        axs[2, 1].grid(True)
        
        plt.tight_layout()
        return fig
    except Exception as e:
        st.error(f"Error loading training history: {e}")
        return None

def compare_metrics(original_sequences, gumbel_sequences, improved_sequences):
    """Compare metrics between original and generated sequences."""
    metrics = {
        'GC Content': [
            calculate_gc_content_from_sequences(original_sequences),
            calculate_gc_content_from_sequences(gumbel_sequences),
            calculate_gc_content_from_sequences(improved_sequences)
        ],
        'Sequence Diversity': [
            len(set([seq['sequence'] for seq in original_sequences])) / len(original_sequences),
            len(set([seq['sequence'] for seq in gumbel_sequences])) / len(gumbel_sequences),
            len(set([seq['sequence'] for seq in improved_sequences])) / len(improved_sequences)
        ],
        'Average Length': [
            np.mean([seq['length'] for seq in original_sequences]),
            np.mean([seq['length'] for seq in gumbel_sequences]),
            np.mean([seq['length'] for seq in improved_sequences])
        ]
    }
    
    # Create DataFrame
    df = pd.DataFrame(metrics, index=['Original', 'Gumbel-Softmax GAN', 'Improved WGAN-GP'])
    
    return df

def plot_metrics_comparison(metrics_df):
    """Plot metrics comparison."""
    fig, axs = plt.subplots(1, len(metrics_df.columns), figsize=(15, 5))
    
    for i, metric in enumerate(metrics_df.columns):
        axs[i].bar(metrics_df.index, metrics_df[metric])
        axs[i].set_title(metric)
        axs[i].set_ylabel('Value')
        axs[i].tick_params(axis='x', rotation=45)
        axs[i].grid(axis='y', linestyle='--', alpha=0.7)
    
    plt.tight_layout()
    return fig

# Main app
def main():
    st.title("ðŸ§¬ DNA Sequence Generation Dashboard")
    
    # Sidebar
    st.sidebar.title("Navigation")
    page = st.sidebar.radio(
        "Select a page",
        ["Home", "Original Data", "Generated Data", "Model Comparison", "Training Progress"]
    )
    
    # Data paths
    data_path = "../data"
    original_data_path = os.path.join(data_path, "clean_all_dna_sequences.fasta")
    gumbel_data_path = os.path.join(data_path, "gumbel_generated_sequences.fasta")
    improved_data_path = os.path.join(data_path, "improved_generated_sequences.fasta")
    
    # Check if files exist, otherwise use placeholders
    if not os.path.exists(original_data_path):
        st.sidebar.warning(f"Original data file not found: {original_data_path}")
        original_data_path = None
    
    if not os.path.exists(gumbel_data_path):
        st.sidebar.warning(f"Gumbel-Softmax generated data file not found: {gumbel_data_path}")
        gumbel_data_path = None
    
    if not os.path.exists(improved_data_path):
        st.sidebar.warning(f"Improved WGAN-GP generated data file not found: {improved_data_path}")
        improved_data_path = None
    
    # Home page
    if page == "Home":
        st.header("Welcome to the DNA Sequence Generation Dashboard")
        
        st.markdown("""
        This dashboard allows you to explore and compare DNA sequences generated by different GAN models.
        
        ### Available Models:
        
        1. **Gumbel-Softmax GAN**
           - Uses LSTM generator with 256 hidden units
           - Applies Gumbel-Softmax trick for backpropagation through discrete outputs
           - Prone to mode collapse
        
        2. **Improved WGAN-GP**
           - Uses Wasserstein loss with gradient penalty
           - LSTM generator with self-attention mechanism
           - More stable training and better diversity
        
        ### Features:
        
        - View original DNA sequences
        - Explore generated sequences from both models
        - Compare evaluation metrics
        - Visualize training progress
        
        Use the navigation panel on the left to explore different sections.
        """)
        
        st.subheader("Project Structure")
        st.markdown("""
        ```
        DNA_GAN_Project/
        â”œâ”€â”€ models/
        â”‚   â”œâ”€â”€ gumbel_softmax_gan/  # Original GAN implementation
        â”‚   â””â”€â”€ improved_wgan/       # Improved WGAN-GP implementation
        â”œâ”€â”€ data/                    # Original and generated sequences
        â”œâ”€â”€ evaluation/              # Evaluation scripts and results
        â”œâ”€â”€ visualization/           # Visualization tools (including this app)
        â”œâ”€â”€ utils/                   # Utility functions
        â””â”€â”€ docs/                    # Documentation
        ```
        """)
    
    # Original Data page
    elif page == "Original Data":
        st.header("Original DNA Sequences")
        
        if original_data_path and os.path.exists(original_data_path):
            original_sequences = load_fasta_sequences(original_data_path)
            
            st.subheader("Sample Sequences")
            sample_df = pd.DataFrame([
                {'ID': seq['id'], 'Sequence': seq['sequence'], 'Length': seq['length']}
                for seq in original_sequences[:10]
            ])
            st.dataframe(sample_df)
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("Nucleotide Distribution")
                nucleotide_freq = calculate_nucleotide_frequencies(original_sequences)
                fig = plot_nucleotide_distribution(nucleotide_freq, "Original Data Nucleotide Distribution")
                st.pyplot(fig)
                
                st.subheader("GC Content")
                gc_content = calculate_gc_content_from_sequences(original_sequences)
                st.metric("GC Content", f"{gc_content:.2%}")
            
            with col2:
                st.subheader("Sequence Length Distribution")
                fig = plot_sequence_length_distribution(original_sequences)
                st.pyplot(fig)
                
                st.subheader("Top k-mers (k=3)")
                kmer_freq = calculate_kmer_frequencies(original_sequences, k=3)
                fig = plot_kmer_distribution(kmer_freq)
                st.pyplot(fig)
        else:
            st.error("Original data file not found. Please check the file path.")
    
    # Generated Data page
    elif page == "Generated Data":
        st.header("Generated DNA Sequences")
        
        model_option = st.selectbox(
            "Select model",
            ["Gumbel-Softmax GAN", "Improved WGAN-GP"]
        )
        
        if model_option == "Gumbel-Softmax GAN":
            if gumbel_data_path and os.path.exists(gumbel_data_path):
                gumbel_sequences = load_fasta_sequences(gumbel_data_path)
                
                st.subheader("Sample Generated Sequences")
                sample_df = pd.DataFrame([
                    {'ID': seq['id'], 'Sequence': seq['sequence'], 'Length': seq['length']}
                    for seq in gumbel_sequences[:10]
                ])
                st.dataframe(sample_df)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Nucleotide Distribution")
                    nucleotide_freq = calculate_nucleotide_frequencies(gumbel_sequences)
                    fig = plot_nucleotide_distribution(nucleotide_freq, "Gumbel-Softmax GAN Nucleotide Distribution")
                    st.pyplot(fig)
                    
                    st.subheader("GC Content")
                    gc_content = calculate_gc_content_from_sequences(gumbel_sequences)
                    st.metric("GC Content", f"{gc_content:.2%}")
                
                with col2:
                    st.subheader("Sequence Length Distribution")
                    fig = plot_sequence_length_distribution(gumbel_sequences)
                    st.pyplot(fig)
                    
                    st.subheader("Top k-mers (k=3)")
                    kmer_freq = calculate_kmer_frequencies(gumbel_sequences, k=3)
                    fig = plot_kmer_distribution(kmer_freq)
                    st.pyplot(fig)
            else:
                st.error("Gumbel-Softmax generated data file not found. Please check the file path.")
        
        else:  # Improved WGAN-GP
            if improved_data_path and os.path.exists(improved_data_path):
                improved_sequences = load_fasta_sequences(improved_data_path)
                
                st.subheader("Sample Generated Sequences")
                sample_df = pd.DataFrame([
                    {'ID': seq['id'], 'Sequence': seq['sequence'], 'Length': seq['length']}
                    for seq in improved_sequences[:10]
                ])
                st.dataframe(sample_df)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.subheader("Nucleotide Distribution")
                    nucleotide_freq = calculate_nucleotide_frequencies(improved_sequences)
                    fig = plot_nucleotide_distribution(nucleotide_freq, "Improved WGAN-GP Nucleotide Distribution")
                    st.pyplot(fig)
                    
                    st.subheader("GC Content")
                    gc_content = calculate_gc_content_from_sequences(improved_sequences)
                    st.metric("GC Content", f"{gc_content:.2%}")
                
                with col2:
                    st.subheader("Sequence Length Distribution")
                    fig = plot_sequence_length_distribution(improved_sequences)
                    st.pyplot(fig)
                    
                    st.subheader("Top k-mers (k=3)")
                    kmer_freq = calculate_kmer_frequencies(improved_sequences, k=3)
                    fig = plot_kmer_distribution(kmer_freq)
                    st.pyplot(fig)
            else:
                st.error("Improved WGAN-GP generated data file not found. Please check the file path.")
    
    # Model Comparison page
    elif page == "Model Comparison":
        st.header("Model Comparison")
        
        # Load data if available
        original_sequences = []
        gumbel_sequences = []
        improved_sequences = []
        
        if original_data_path and os.path.exists(original_data_path):
            original_sequences = load_fasta_sequences(original_data_path)
        else:
            st.error("Original data file not found. Please check the file path.")
        
        if gumbel_data_path and os.path.exists(gumbel_data_path):
            gumbel_sequences = load_fasta_sequences(gumbel_data_path)
        else:
            st.error("Gumbel-Softmax generated data file not found. Please check the file path.")
        
        if improved_data_path and os.path.exists(improved_data_path):
            improved_sequences = load_fasta_sequences(improved_data_path)
        else:
            st.error("Improved WGAN-GP generated data file not found. Please check the file path.")
        
        if original_sequences and gumbel_sequences and improved_sequences:
            # Compare metrics
            metrics_df = compare_metrics(original_sequences, gumbel_sequences, improved_sequences)
            
            st.subheader("Metrics Comparison")
            st.dataframe(metrics_df.style.format("{:.4f}"))
            
            st.subheader("Metrics Visualization")
            fig = plot_metrics_comparison(metrics_df)
            st.pyplot(fig)
            
            # Compare nucleotide distributions
            st.subheader("Nucleotide Distribution Comparison")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.markdown("**Original Data**")
                nucleotide_freq = calculate_nucleotide_frequencies(original_sequences)
                fig = plot_nucleotide_distribution(nucleotide_freq, "Original")
                st.pyplot(fig)
            
            with col2:
                st.markdown("**Gumbel-Softmax GAN**")
                nucleotide_freq = calculate_nucleotide_frequencies(gumbel_sequences)
                fig = plot_nucleotide_distribution(nucleotide_freq, "Gumbel-Softmax GAN")
                st.pyplot(fig)
            
            with col3:
                st.markdown("**Improved WGAN-GP**")
                nucleotide_freq = calculate_nucleotide_frequencies(improved_sequences)
                fig = plot_nucleotide_distribution(nucleotide_freq, "Improved WGAN-GP")
                st.pyplot(fig)
            
            # Compare k-mer distributions
            st.subheader("Top k-mers Comparison (k=3)")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.markdown("**Original Data**")
                kmer_freq = calculate_kmer_frequencies(original_sequences, k=3)
                fig = plot_kmer_distribution(kmer_freq, "Original")
                st.pyplot(fig)
            
            with col2:
                st.markdown("**Gumbel-Softmax GAN**")
                kmer_freq = calculate_kmer_frequencies(gumbel_sequences, k=3)
                fig = plot_kmer_distribution(kmer_freq, "Gumbel-Softmax GAN")
                st.pyplot(fig)
            
            with col3:
                st.markdown("**Improved WGAN-GP**")
                kmer_freq = calculate_kmer_frequencies(improved_sequences, k=3)
                fig = plot_kmer_distribution(kmer_freq, "Improved WGAN-GP")
                st.pyplot(fig)
            
            # Conclusion
            st.subheader("Conclusion")
            
            st.markdown("""
            ### Key Findings:
            
            1. **GC Content**: The Improved WGAN-GP model generates sequences with GC content closer to the original data compared to the Gumbel-Softmax GAN.
            
            2. **Sequence Diversity**: The Improved WGAN-GP model produces more diverse sequences, avoiding the mode collapse observed in the Gumbel-Softmax GAN.
            
            3. **Nucleotide Distribution**: The nucleotide distribution of sequences generated by the Improved WGAN-GP model more closely matches the original data.
            
            4. **k-mer Patterns**: The Improved WGAN-GP model better captures the k-mer patterns present in the original data.
            
            ### Overall Assessment:
            
            The Improved WGAN-GP model significantly outperforms the Gumbel-Softmax GAN in generating realistic DNA sequences. The Wasserstein loss with gradient penalty provides more stable training and helps avoid mode collapse, resulting in more diverse and biologically plausible sequences.
            """)
    
    # Training Progress page
    elif page == "Training Progress":
        st.header("Training Progress")
        
        model_option = st.selectbox(
            "Select model",
            ["Gumbel-Softmax GAN", "Improved WGAN-GP"]
        )
        
        if model_option == "Gumbel-Softmax GAN":
            history_path = "../models/gumbel_softmax_gan/checkpoints/training_history.json"
            
            if os.path.exists(history_path):
                fig = plot_training_history(history_path, "Gumbel-Softmax GAN Training History")
                if fig:
                    st.pyplot(fig)
                
                st.subheader("Training Analysis")
                st.markdown("""
                ### Gumbel-Softmax GAN Training Analysis:
                
                1. **Discriminator Accuracy**: The discriminator quickly achieves perfect accuracy, indicating that it can easily distinguish between real and generated sequences.
                
                2. **Generator Loss**: The generator loss increases over time, suggesting that the generator is struggling to produce sequences that can fool the discriminator.
                
                3. **GC Content**: The GC content of generated sequences rapidly decreases, indicating that the generator is producing sequences dominated by A and T nucleotides.
                
                4. **Diversity**: Sequence diversity quickly decreases, suggesting that the generator is producing similar or identical sequences (mode collapse).
                
                These patterns strongly indicate that the model experienced mode collapse, a common problem in GAN training where the generator produces limited varieties of outputs.
                """)
            else:
                st.error(f"Training history file not found: {history_path}")
        
        else:  # Improved WGAN-GP
            history_path = "../models/improved_wgan/checkpoints/improved_dna_gan/training_history.json"
            
            if os.path.exists(history_path):
                fig = plot_training_history(history_path, "Improved WGAN-GP Training History")
                if fig:
                    st.pyplot(fig)
                
                st.subheader("Training Analysis")
                st.markdown("""
                ### Improved WGAN-GP Training Analysis:
                
                1. **Wasserstein Distance**: The Wasserstein distance gradually decreases, indicating that the generator is learning to produce sequences that are more similar to real sequences.
                
                2. **Gradient Penalty**: The gradient penalty remains stable, helping to enforce the Lipschitz constraint and provide stable gradients.
                
                3. **GC Content**: The GC content of generated sequences stabilizes at a value close to that of real sequences.
                
                4. **Diversity**: Sequence diversity remains high throughout training, indicating that the generator is producing a variety of different sequences.
                
                These patterns suggest that the Wasserstein loss with gradient penalty provides more stable training and helps avoid mode collapse, resulting in more diverse and biologically plausible sequences.
                """)
            else:
                st.error(f"Training history file not found: {history_path}")


if __name__ == "__main__":
    main()
